Build an infinite scrolling component that automatically loads more data as users scroll down. The key challenges are detecting when the user reaches the bottom, preventing duplicate API calls, and providing smooth loading states.

## Overview

Infinite scrolling (also called "endless scroll" or "virtual scrolling") automatically loads more content when the user scrolls near the bottom of a container. Instead of traditional pagination with "Next" buttons, content loads seamlessly as the user scrolls, creating a continuous browsing experience.

## Architecture Overview

The implementation uses a **three-layer architecture**:

```
┌─────────────────────────────────────┐
│  InfiniteScrollingDemo (Parent)     │
│  - Manages data state               │
│  - Handles API calls                │
│  - Controls loading states          │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│  InfiniteScrollingComponent         │
│  - Renders children                 │
│  - Shows loader/end message         │
│  - Places sentinel element          │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│  useInfiniteScroll Hook             │
│  - Intersection Observer setup      │
│  - Triggers onLoadMore callback     │
│  - Prevents duplicate calls         │
└─────────────────────────────────────┘
```

**Key Components:**
1. **Sentinel Element**: An invisible div at the bottom that triggers loading when it becomes visible
2. **Intersection Observer**: Browser API that watches when the sentinel enters the viewport
3. **Loading Guard**: Prevents multiple simultaneous API calls

## Core Challenge: Detecting Scroll Position

The main challenge is knowing **when** to load more data. We need to detect when the user is near the bottom without constantly checking scroll position (which is expensive).

### The Problem with Scroll Events

```tsx
// BAD: Expensive and inefficient
useEffect(() => {
    const handleScroll = () => {
        const { scrollTop, scrollHeight, clientHeight } = containerRef.current;
        if (scrollTop + clientHeight >= scrollHeight - 100) {
            loadMore();
        }
    };
    container.addEventListener('scroll', handleScroll);
}, []);
```

**Issues:**
- Fires hundreds of times per second during scrolling
- Requires manual calculations
- Can cause performance issues
- Hard to optimize

### The Solution: Intersection Observer API

The Intersection Observer API watches when an element enters or exits the viewport (or a specified root element). It's:
- **Efficient**: Only fires when intersection changes, not continuously
- **Native**: Built into browsers, no manual calculations
- **Flexible**: Can observe multiple elements with one observer
- **Performant**: Uses browser optimizations

## Intersection Observer API

The Intersection Observer is a browser API that asynchronously observes changes in the intersection of a target element with an ancestor element or the viewport.

### Basic Setup

```tsx
const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
        if (entry.isIntersecting) {
            // Element is visible
            onLoadMore();
        }
    });
}, {
    root: null,           // Viewport (default)
    rootMargin: '200px',  // Trigger 200px before element is visible
    threshold: 0          // Trigger when any part is visible
});

observer.observe(sentinelElement);
```

### Configuration Options

**`root`**: The element used as the viewport for checking visibility
- `null` = browser viewport
- `document.getElementById('container')` = specific container

**`rootMargin`**: Margin around the root (like CSS margin)
- `'200px'` = trigger 200px before element enters viewport
- `'0px'` = trigger exactly when element enters
- `'-100px'` = trigger 100px after element enters

**`threshold`**: Percentage of element that must be visible
- `0` = trigger when any pixel is visible
- `0.5` = trigger when 50% is visible
- `1` = trigger when 100% is visible

### Why `rootMargin: '200px'`?

Setting `rootMargin: '200px'` means the observer triggers **200px before** the sentinel element actually becomes visible. This:
- Loads data **before** the user reaches the bottom
- Creates a seamless experience (no waiting)
- Hides loading time from the user

```
┌─────────────────────────────┐
│  Visible Content            │
│                             │
│  ┌─────────────────────┐   │
│  │  Item 1             │   │
│  │  Item 2             │   │
│  │  Item 3             │   │
│  │  ...                │   │
│  └─────────────────────┘   │
│  ────────────────────────  │ ← 200px margin
│  ────────────────────────  │
│  [Sentinel Element]        │ ← Triggers here
│  ────────────────────────  │
│  [Bottom of Container]     │
└─────────────────────────────┘
```

## Implementation: Custom Hook

The `useInfiniteScroll` hook encapsulates all Intersection Observer logic:

```tsx
const useInfiniteScrolling = ({
    onLoadMore,
    hasMore,
    root = null,
    rootMargin = "200px",
    disabled = false
}: UseInfiniteScrollingProps) => {
    const observerRef = useRef<HTMLDivElement | null>(null);
    const loadingRef = useRef(false);

    useEffect(() => {
        if (disabled || !hasMore) return;
        if (!observerRef.current) return;

        const observer = new IntersectionObserver((entries) => {
            const [entry] = entries;
            if (entry.isIntersecting && !loadingRef.current && hasMore) {
                loadingRef.current = true;
                onLoadMore();
                // Reset loading flag after a short delay
                setTimeout(() => {
                    loadingRef.current = false;
                }, 100);
            }
        }, {
            root,
            rootMargin
        })

        observer.observe(observerRef.current);
        return () => {
            observer.disconnect();
        }
    }, [onLoadMore, hasMore, root, rootMargin, disabled])

    return { observerRef };
}
```

### Key Features

**1. Loading Guard (`loadingRef`)**
```tsx
const loadingRef = useRef(false);
```
Prevents multiple simultaneous API calls:
- Set to `true` when `onLoadMore` is called
- Reset after 100ms delay
- Prevents rapid-fire triggers during fast scrolling

**2. Conditional Observation**
```tsx
if (disabled || !hasMore) return;
```
Stops observing when:
- Hook is disabled
- No more data available (`hasMore = false`)

**3. Cleanup**
```tsx
return () => {
    observer.disconnect();
}
```
Properly disconnects the observer when:
- Component unmounts
- Dependencies change
- Prevents memory leaks

## Component Architecture

### 1. InfiniteScrollingComponent (Container)

The container component manages rendering and provides the sentinel element:

```tsx
const InfiniteScrollingComponent = ({
    children,
    onLoadMore,
    hasMore,
    isLoading,
    loader = null,
    endMessage = null
}: InfiniteScrollingComponentProps) => {
    const { observerRef } = useInfiniteScrolling({
        onLoadMore,
        hasMore: hasMore && !isLoading  // Disable when loading
    });

    return (
        <div className="infinite-scrolling-component">
            {children}
            {isLoading && loader}
            {hasMore ? (
                <div ref={observerRef} className="infinite-scroll-sentinel" />
            ) : (
                endMessage
            )}
        </div>
    )
}
```

**Responsibilities:**
- Renders children (the actual content items)
- Shows loading skeleton when `isLoading` is true
- Places sentinel element when `hasMore` is true
- Shows end message when all data is loaded

**Why `hasMore && !isLoading`?**
Disabling the observer during loading prevents:
- Multiple triggers while data is being fetched
- Race conditions
- Duplicate API calls

### 2. InfiniteScrollingDemo (Parent)

The parent component manages all state and data fetching:

```tsx
const InfiniteScrollingDemo = () => {
    const [data, setData] = useState<DataItem[]>([]);
    const [loading, setLoading] = useState(false);
    const [hasMore, setHasMore] = useState(true);
    const [page, setPage] = useState(1);
    const maxItems = 100;

    const loadMoreData = useCallback(async () => {
        if (loading || !hasMore) return;

        setLoading(true);
        try {
            const newData = await fetchMoreData(page);
            
            if (data.length + newData.length >= maxItems) {
                setHasMore(false);
            }
            
            setData(prev => [...prev, ...newData]);
            setPage(prev => prev + 1);
        } catch (error) {
            console.error('Error loading more data:', error);
        } finally {
            setLoading(false);
        }
    }, [data.length, loading, hasMore, page]);

    // Load initial data
    React.useEffect(() => {
        loadMoreData();
    }, []);

    return (
        <div className="infinite-scrolling-demo">
            <InfiniteScrollingComponent
                hasMore={hasMore}
                isLoading={loading}
                onLoadMore={loadMoreData}
                loader={<Skeleton />}
                endMessage={<EmptyState />}
            >
                {data.map(item => (
                    <div key={item.id} className="box">
                        {item.content}
                    </div>
                ))}
            </InfiniteScrollingComponent>
        </div>
    )
}
```

**State Management:**
- `data`: Array of loaded items
- `loading`: Whether an API call is in progress
- `hasMore`: Whether more data is available
- `page`: Current page number for pagination

**Why `useCallback`?**
Wrapping `loadMoreData` in `useCallback` prevents:
- Recreating the function on every render
- Causing the Intersection Observer to re-initialize
- Unnecessary effect re-runs

## Mock API Implementation

The demo uses a mock API function to simulate real data fetching:

```tsx
const fetchMoreData = async (
    page: number, 
    pageSize: number = 10
): Promise<DataItem[]> => {
    // Simulate API delay
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    const startId = (page - 1) * pageSize + 1;
    return Array.from({ length: pageSize }, (_, index) => ({
        id: startId + index,
        content: `Item ${startId + index}`
    }));
}
```

**How it works:**
1. **Delay**: `setTimeout` simulates network latency (1 second)
2. **Pagination**: Calculates starting ID based on page number
3. **Page Size**: Returns 10 items per page (configurable)

**Real-world usage:**
Replace with actual API call:
```tsx
const fetchMoreData = async (page: number) => {
    const response = await fetch(`/api/items?page=${page}&limit=10`);
    return response.json();
}
```

## Loading States

### Skeleton Loader

Shows a placeholder while data is loading:

```tsx
const Skeleton = () => (
    <div className="box skeleton">
        <div className="skeleton-content">Loading...</div>
    </div>
);
```

**CSS Animation:**
```css
.skeleton-content {
    background: linear-gradient(
        90deg,
        #2d3748 0%,
        #4a5568 50%,
        #2d3748 100%
    );
    background-size: 200% 100%;
    animation: loading 1.5s ease-in-out infinite;
}

@keyframes loading {
    0% { background-position: 200% 0; }
    100% { background-position: -200% 0; }
}
```

Creates a shimmer effect that indicates loading without showing actual content.

### Empty State

Shows when all data has been loaded:

```tsx
const EmptyState = () => (
    <div className="empty-state">
        <p>No more items to load</p>
    </div>
);
```

## Sentinel Element

The sentinel is an invisible element placed at the bottom of the content:

```tsx
{hasMore ? (
    <div ref={observerRef} className="infinite-scroll-sentinel" />
) : (
    endMessage
)}
```

**CSS:**
```css
.infinite-scroll-sentinel {
    height: 1px;
    width: 100%;
}
```

**Why invisible?**
- Doesn't affect layout
- Doesn't distract users
- Only serves as a trigger point for the observer

## Preventing Duplicate Calls

Multiple mechanisms prevent duplicate API calls:

### 1. Loading Guard in Hook
```tsx
if (entry.isIntersecting && !loadingRef.current && hasMore) {
    loadingRef.current = true;
    onLoadMore();
}
```

### 2. Guard in Parent Component
```tsx
const loadMoreData = useCallback(async () => {
    if (loading || !hasMore) return;  // Early return
    // ... fetch data
}, [loading, hasMore, ...]);
```

### 3. Disable Observer During Loading
```tsx
const { observerRef } = useInfiniteScrolling({
    onLoadMore,
    hasMore: hasMore && !isLoading  // Disabled when loading
});
```

**Defense in depth:** Multiple layers ensure no duplicate calls even if one mechanism fails.

## Scroll Container Setup

The container must have:
- Fixed height
- `overflow-y: auto` (or `scroll`)

```css
.infinite-scrolling-demo {
    height: 600px;
    overflow-y: auto;
    /* ... */
}
```

**Why fixed height?**
- Scroll container must be defined for Intersection Observer
- Without a scroll container, observer uses viewport (not what we want)
- Enables scrolling within the component

**For viewport scrolling:**
If you want to scroll the entire page instead:
```tsx
const { observerRef } = useInfiniteScrolling({
    onLoadMore,
    hasMore,
    root: null  // Uses viewport
});
```

## Error Handling

Always handle errors in data fetching:

```tsx
const loadMoreData = useCallback(async () => {
    if (loading || !hasMore) return;
    
    setLoading(true);
    try {
        const newData = await fetchMoreData(page);
        setData(prev => [...prev, ...newData]);
        setPage(prev => prev + 1);
    } catch (error) {
        console.error('Error loading more data:', error);
        // Optionally: show error message to user
        // setError('Failed to load more items');
    } finally {
        setLoading(false);
    }
}, []);
```

**Why `finally`?**
Ensures `loading` is always reset, even if an error occurs.

## Performance Considerations

### 1. Memoization
```tsx
const loadMoreData = useCallback(async () => {
    // ...
}, [data.length, loading, hasMore, page]);
```
Prevents unnecessary re-renders and observer re-initialization.

### 2. Efficient Updates
```tsx
setData(prev => [...prev, ...newData]);
```
Uses functional update to avoid dependency on `data` in callback.

### 3. Cleanup
```tsx
useEffect(() => {
    // ... setup observer
    return () => {
        observer.disconnect();
    }
}, [dependencies]);
```
Prevents memory leaks by disconnecting observers.

## Advanced Patterns

### Virtual Scrolling

For very large lists (thousands of items), consider virtual scrolling:
- Only render visible items
- Reuse DOM elements
- Libraries: `react-window`, `react-virtualized`

### Debouncing

If API calls are expensive, debounce the `onLoadMore` callback:

```tsx
const debouncedLoadMore = useMemo(
    () => debounce(loadMoreData, 300),
    [loadMoreData]
);
```

### Caching

Cache loaded pages to avoid re-fetching:

```tsx
const [cache, setCache] = useState<Record<number, DataItem[]>>({});

const loadMoreData = useCallback(async () => {
    if (cache[page]) {
        setData(prev => [...prev, ...cache[page]]);
        return;
    }
    // ... fetch and cache
}, [page, cache]);
```

## Key Takeaways

1. **Intersection Observer**: Use instead of scroll events for better performance
2. **Sentinel Element**: Invisible element at bottom triggers loading
3. **rootMargin**: Trigger loading before user reaches bottom (better UX)
4. **Loading Guards**: Multiple layers prevent duplicate API calls
5. **useCallback**: Memoize callbacks to prevent unnecessary re-renders
6. **Error Handling**: Always handle API errors gracefully
7. **Cleanup**: Disconnect observers to prevent memory leaks
8. **State Management**: Track `loading`, `hasMore`, and `data` separately

The beauty of this approach is its simplicity and efficiency. The Intersection Observer API handles all the heavy lifting, and the component architecture keeps concerns separated. Whether loading 10 items or 10,000, the same pattern works perfectly.
